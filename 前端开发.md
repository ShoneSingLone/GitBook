# 一个前端的自我修养 Web Fundamentals

前端的本职工作当然是做好UI开发，也就是切图仔啦(其实是用户关心什么就最先给出来)。

## 资料

[大厂 UI 开发实战手册](https://juejin.im/book/5a7bfe595188257a7349b52a)
[基于指令和混合的前端通用埋点方案](https://juejin.im/entry/5958e9086fb9a06bb95abe4a)

- 分析用户行为
- 观察产品使用状况
- 制定产品策略

[《CSS揭秘》](https)

## 大体的层次

1. 得到设计师的设计方案
1. 思考可行性，分析涉及到的数据存储、传送问题，优化设计方案
1. 实现页面的静态前端布局及界面原型
1. 配置服务器，建立数据库、写API接口，并对接口进行单元测试
1. 修改页面代码，使之调用API从服务端请求数据并完成界面展示

### 页面还原（切图、结构）

### 流畅、兼容、健壮（响应式）

自适应与响应式的区别

### 体验、有吸引力（动画）

首先完成静态页面
在添加动画效果

### MVVM

[前端框架到底在闹腾个啥？](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650588269&idx=1&sn=bf830636883038ec6b51e6da722acb4c&chksm=8891d449bfe65d5f27e0e3a5aee43d46641595e6d29d464a0863966936ad0d0dc6f624a9cfb7&scene=0#rd)
UI = render(State)

视图与数据之间的映射

## 参考

- [关键渲染路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/)
- [重排重绘，看这一篇就够了](https://juejin.im/entry/582f16fca22b9d006b7afd89)
- [offsetParent](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent)
- [Js中 关于top、clientTop、scrollTop、offsetTop](http://www.cnblogs.com/seven_cheng/archive/2009/11/16/1603787.html)

---

- [阻塞渲染的 CSS](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)

## What

Easy to say，就是需要知道浏览器拿着HTML、CSS、JavaScript干了啥，怎么干的，然后优化


## Why

用户只关心看到的部分 → 这一部分需要人为提高处理的优先级 → 就要知道浏览器处理HTML、CSS、JavaScript的流程节点——**关键渲染路径**

## How

### 基本

- 学会使用 Chrome 的performance（原为Timeline）做性能分析；基本原则先衡量在谈优化；
- DOM：

characters→Tokens→Nodes→DOM
特点是可以一行一行的加载，期间遇到link CSS script JavaScript 就发送request，拿到response进行CSSOM 和执行Script（可能因为defer 或者 async而不同）。所以理论上DOM完成之后，CSSOM应该已经完成。

- CSSOM

characters→Tokens→Nodes→CSSOM

DOM + CSSOM ==可见部分==> render Tree（display:none就是不可见，也就不需要render Tree )
 这时候涉及重排和重绘（layout/reflow paint）：一旦需要大小的变换，是肯定需要重排的；既然都重排了，没道理不重绘； 但是像改变背景颜色这种事不需要重排，只需要重绘的。（我似乎在“表述重排后一定重绘，重绘不一定因为重排”）

### 优化optimizing

- 压缩、除去注释、缓存
- HTML size 尽量小

### 分析关键渲染路径性能

[分析关键渲染路径性能](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp#performance-patterns)

- Why： 优化关键渲染路径能够让浏览器尽可能快地绘制网页：更快的网页渲染速度可以提高吸引力、增加网页浏览量以及提高转化率，最大程度减少访客看到空白屏幕的时间。

## 性能

 [Why Performance Matters](https://developers.google.com/web/fundamentals/performance/why-performance-matters/)
- 工程师们为了获得更高性能提供更好的用户体验，在各种网络环境和硬件设备之间挣扎......
- 流量为王，更好的性能能吸引留住更多的用户

[使用 RAIL 模型评估性能](https://developers.google.com/web/fundamentals/performance/rail)
比起之前的258原则，明显要求更细致了。

从浏览器的渲染机制说起，明白中间的关键渲染路径，调整优先级(prioritization)。

[优化 JavaScript 执行](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)

- 对于动画效果的实现，避免使用 setTimeout 或 setInterval，请使- 用 requestAnimationFrame。
- 将长时间运行的 JavaScript 从主线程移到 [Web Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)。
- 使用微任务来执行对多个帧的 DOM 更改。
- 使用 Chrome DevTools 的 Timeline 和 JavaScript 分析器来评估 JavaScript 的影响。

---

- [requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)
- [requestAnimationFrame标准教程](https://javascript.ruanyifeng.com/htmlapi/requestanimationframe.html)
- [requestAnimationFrame 知多少](https://www.cnblogs.com/onepixel/p/7078617.html)
- [CSS3动画那么强，requestAnimationFrame还有毛线用？](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/)
- 简单来说就是以前想用setTimeout的地方直接用requestAnimationFrame就行了，因为是系统是时间，所以帧率很有保障
